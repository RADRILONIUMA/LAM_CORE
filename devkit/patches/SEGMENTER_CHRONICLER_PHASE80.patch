--- segmenter_blocks.py
+++ segmenter_blocks.py
@@ -37,6 +37,7 @@
 import time
 from datetime import datetime, timezone
 from pathlib import Path
+from kingdom_vocabulary import discern_vector
 from typing import Dict, Iterable, List, Optional, Tuple
 
 
@@ -160,6 +161,16 @@
     return sorted(tags)
 
 
+def extract_sacred_metadata(text: str, filename: str) -> Dict[str, str]:
+    """Extract sacred vector and additional metadata."""
+    vector = discern_vector(text, filename)
+    tags = extract_tags(text)
+    return {
+        "vector": vector,
+        "tags": tags
+    }
+
+
 def split_into_blocks(
     text: str,
     max_chars: int,
@@ -178,13 +189,22 @@
         # Determine size of next character in UTFâ€‘8
         ch_bytes = ch.encode("utf-8")
         next_byte_count = len(ch_bytes)
+        
         # If adding this char would exceed either limit, finalize current block
         if char_count + 1 > max_chars or byte_count + next_byte_count > max_bytes:
-            blocks.append(text[start:idx])
-            start = idx
+            # Healing: Smart slice (space or newline)
+            split_idx = idx
+            for lookback in range(1, min(500, idx - start)):
+                if text[idx - lookback] in " 
	":
+                    split_idx = idx - lookback + 1
+                    break
+            
+            blocks.append(text[start:split_idx].strip())
+            start = split_idx
             char_count = 0
             byte_count = 0
-        char_count += 1
-        byte_count += next_byte_count
+        
+        char_count, byte_count = len(text[start:idx+1]), len(text[start:idx+1].encode("utf-8"))
     # Add last block
     if start < len(text):
         blocks.append(text[start:].strip())
